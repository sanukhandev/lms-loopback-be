import {authenticate} from '@loopback/authentication';
import {authorize} from '@loopback/authorization';
import {inject} from '@loopback/core';
import {Filter, repository} from '@loopback/repository';
import {
  HttpErrors,
  Request,
  RestBindings,
  SchemaObject,
  get,
  param,
  patch,
  post,
  requestBody,
  response,
} from '@loopback/rest';
import {randomBytes} from 'node:crypto';
import {Logger} from 'pino';
import {PasswordHasher} from '../auth/types';
import {AuthBindings, LoggingBindings} from '../bindings/keys';
import {User} from '../models';
import {UserRepository} from '../repositories';
import {extractTenantId, sanitizeTenantId} from '../utils/tenant';

const STUDENT_VIEW_SCHEMA: SchemaObject = {
  type: 'object',
  properties: {
    id: {type: 'string'},
    email: {type: 'string', format: 'email'},
    firstName: {type: 'string'},
    lastName: {type: 'string'},
    roles: {
      type: 'array',
      items: {type: 'string'},
      description: 'Assigned roles for the user within the tenant',
    },
    status: {type: 'string'},
    tenantId: {type: 'string'},
    createdAt: {type: 'string', format: 'date-time'},
    updatedAt: {type: 'string', format: 'date-time'},
  },
};

const STUDENT_CREATE_SCHEMA: SchemaObject = {
  type: 'object',
  required: ['email', 'firstName', 'lastName'],
  properties: {
    email: {type: 'string', format: 'email'},
    firstName: {type: 'string', minLength: 1},
    lastName: {type: 'string', minLength: 1},
    password: {type: 'string', minLength: 8},
    status: {
      type: 'string',
      enum: ['active', 'invited', 'inactive', 'suspended'],
      default: 'active',
    },
  },
};

const STUDENT_UPDATE_SCHEMA: SchemaObject = {
  type: 'object',
  properties: {
    firstName: {type: 'string', minLength: 1},
    lastName: {type: 'string', minLength: 1},
    password: {type: 'string', minLength: 8},
    status: {
      type: 'string',
      enum: ['active', 'invited', 'inactive', 'suspended'],
    },
  },
};

interface StudentCreateRequest {
  email: string;
  firstName: string;
  lastName: string;
  password?: string;
  status?: string;
}

interface StudentUpdateRequest {
  firstName?: string;
  lastName?: string;
  password?: string;
  status?: string;
}

interface StudentView {
  id?: string;
  email: string;
  firstName: string;
  lastName: string;
  roles: string[];
  status?: string;
  tenantId: string;
  createdAt?: string;
  updatedAt?: string;
}

interface StudentCreateResponse {
  student: StudentView;
  temporaryPassword?: string;
}

@authenticate('jwt')
export class StudentsController {
  constructor(
    @repository(UserRepository)
    private readonly userRepository: UserRepository,
    @inject(AuthBindings.PASSWORD_HASHER)
    private readonly passwordHasher: PasswordHasher,
    @inject(RestBindings.Http.REQUEST)
    private readonly request: Request,
    @inject(LoggingBindings.LOGGER)
    private readonly logger: Logger,
  ) { }

  @authorize({allowedRoles: ['tenantAdmin']})
  @post('/tenant/students')
  @response(201, {
    description: 'Create a student within the current tenant',
    content: {
      'application/json': {
        schema: {
          type: 'object',
          properties: {
            student: STUDENT_VIEW_SCHEMA,
            temporaryPassword: {
              type: 'string',
              description:
                'Password generated by the system when one is not supplied',
            },
          },
        },
      },
    },
  })
  async createStudent(
    @requestBody({content: {'application/json': {schema: STUDENT_CREATE_SCHEMA}}})
    body: StudentCreateRequest,
  ): Promise<StudentCreateResponse> {
    const tenantId = sanitizeTenantId(extractTenantId(this.request));
    const email = body.email.toLowerCase();


    const existing = await this.userRepository.findOne({
      where: {email, tenantId},
    });
    if (existing) {
      this.logger.warn(
        this.buildLogContext(tenantId, {
          email,
          studentId: existing.id,
        }),
        'student email already registered',
      );
      throw new HttpErrors.Conflict('Email is already registered for this tenant');
    }

    const password = body.password ?? this.generateTemporaryPassword();
    const hashedPassword = await this.passwordHasher.hashPassword(password);

    const user = await this.userRepository.create({
      email,
      firstName: body.firstName,
      lastName: body.lastName,
      password: hashedPassword,
      roles: ['student'],
      status: this.validateStatus(body.status) ?? 'active',
      tenantId,
    });

    const response = {
      student: this.toView(user),
      temporaryPassword: body.password ? undefined : password,
    };

    this.logger.info(
      this.buildLogContext(tenantId, {
        studentId: user.id,
        email,
        status: response.student.status,
        generatedPassword: !body.password,
      }),
      'student created',
    );

    return response;
  }

  @authorize({allowedRoles: ['tenantAdmin']})
  @get('/tenant/students')
  @response(200, {
    description: 'List students for the current tenant',
    content: {
      'application/json': {
        schema: {type: 'array', items: STUDENT_VIEW_SCHEMA},
      },
    },
  })
  async listStudents(
    @param.query.string('status') status?: string,
  ): Promise<StudentView[]> {
    const tenantId = sanitizeTenantId(extractTenantId(this.request));
    const filter: Filter<User> = {
      where: {
        tenantId,
      },
      order: ['createdAt DESC'],
    };

    if (status) {
      filter.where = {
        ...filter.where,
        status,
      };
    }

    const students = await this.userRepository.find(filter);
    const result = students
      .filter(student => (student.roles ?? []).includes('student'))
      .map(student => this.toView(student));

    this.logger.info(
      this.buildLogContext(tenantId, {
        statusFilter: status,
        resultCount: result.length,
      }),
      'students listed',
    );

    return result;
  }

  @authorize({allowedRoles: ['tenantAdmin']})
  @get('/tenant/students/{id}')
  @response(200, {
    description: 'Retrieve a specific student',
    content: {'application/json': {schema: STUDENT_VIEW_SCHEMA}},
  })
  async getStudent(
    @param.path.string('id') id: string,
  ): Promise<StudentView> {
    const tenantId = sanitizeTenantId(extractTenantId(this.request));
    const student = await this.userRepository.findById(id);
    this.ensureStudentAccess(student, tenantId);
    this.logger.debug(
      this.buildLogContext(tenantId, {
        studentId: student.id,
      }),
      'student retrieved',
    );
    return this.toView(student);
  }

  @authorize({allowedRoles: ['tenantAdmin']})
  @patch('/tenant/students/{id}')
  @response(200, {
    description: 'Update a student profile',
    content: {'application/json': {schema: STUDENT_VIEW_SCHEMA}},
  })
  async updateStudent(
    @param.path.string('id') id: string,
    @requestBody({content: {'application/json': {schema: STUDENT_UPDATE_SCHEMA}}})
    body: StudentUpdateRequest,
  ): Promise<StudentView> {
    const tenantId = sanitizeTenantId(extractTenantId(this.request));
    const student = await this.userRepository.findById(id);
    this.ensureStudentAccess(student, tenantId);

    const updateData: Partial<User> = {};
    if (body.firstName) {
      updateData.firstName = body.firstName;
    }
    if (body.lastName) {
      updateData.lastName = body.lastName;
    }
    if (body.status) {
      updateData.status = this.validateStatus(body.status);
    }
    if (body.password) {
      updateData.password = await this.passwordHasher.hashPassword(
        body.password,
      );
    }

    if (Object.keys(updateData).length === 0) {
      this.logger.debug(
        this.buildLogContext(tenantId, {
          studentId: id,
          noChanges: true,
        }),
        'student update skipped',
      );
      return this.toView(student);
    }

    updateData.updatedAt = new Date().toISOString();
    await this.userRepository.updateById(id, updateData);

    const updated = await this.userRepository.findById(id);
    this.logger.info(
      this.buildLogContext(tenantId, {
        studentId: id,
        updatedFields: Object.keys(updateData).filter(field => field !== 'password'),
        passwordReset: Boolean(body.password),
      }),
      'student updated',
    );
    return this.toView(updated);
  }

  private validateStatus(status?: string): string | undefined {
    if (!status) {
      return undefined;
    }

    const allowed = ['active', 'invited', 'inactive', 'suspended'];
    if (!allowed.includes(status)) {
      throw new HttpErrors.BadRequest(
        `Invalid status value. Allowed values: ${allowed.join(', ')}`,
      );
    }

    return status;
  }

  private ensureStudentAccess(student: User, tenantId: string): void {
    const baseContext = this.buildLogContext(tenantId, {
      studentId: student.id,
    });
    if (!student.tenantId) {
      this.logger.error(baseContext, 'student missing tenant context');
      throw new HttpErrors.BadRequest('Student record is missing tenant context');
    }

    if (sanitizeTenantId(student.tenantId) !== tenantId) {
      this.logger.warn(
        {
          ...baseContext,
          studentTenantId: student.tenantId,
        },
        'student tenant mismatch',
      );
      throw new HttpErrors.Forbidden('Student does not belong to this tenant');
    }

    const roles = student.roles ?? [];
    if (!roles.includes('student')) {
      this.logger.warn(
        {
          ...baseContext,
          roles,
        },
        'target user is not a student',
      );
      throw new HttpErrors.Forbidden('Target user is not a student');
    }
  }

  private toView(user: User): StudentView {
    return {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      roles: user.roles ?? [],
      status: user.status,
      tenantId: user.tenantId,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    };
  }

  private generateTemporaryPassword(): string {
    return randomBytes(6).toString('base64url');
  }

  private buildLogContext(
    tenantId: string,
    extra?: Record<string, unknown>,
  ): Record<string, unknown> {
    return {
      tenantId,
      method: this.request.method,
      path: this.request.originalUrl ?? this.request.url,
      correlationId: this.getCorrelationId(),
      ...extra,
    };
  }

  private getCorrelationId(): string | undefined {
    const requestId = this.request.headers['x-request-id'];
    if (Array.isArray(requestId)) {
      return requestId[0];
    }

    const correlationId = this.request.headers['x-correlation-id'];
    if (Array.isArray(correlationId)) {
      return correlationId[0];
    }

    return requestId ?? correlationId;
  }
}
